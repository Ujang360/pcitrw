<h1>Programming Concepts in the Real World</h1>

<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Attribution-ShareAlike 4.0 International" title="" /></a></p>

<p>There are many aspects to programming that are needed to write code. In this
book we will focus only on some basic concepts that can be explained in
isolation, and may be interesting for non programmers.</p>

<h2>Algorithms</h2>

<h2>Binary Search</h2>

<h3>Example</h3>

<h4>Dictionary</h4>

<p>I want to look for a word in an English dictionary. An intuitive way to do it
is to open the dictionary in a random page look for any word, compare it with
the word I'm looking for and see if it has to be before or after that one.
Then, I repeat the process and on every step the search range gets smaller
until I find out the word I was looking for.</p>

<p>Instead of looking for a random page, the fastest way for any word is to grab
the word in the exact middle. This way each step will discard exactly half of
the options available. Picking a random word has a small chance of discarding
most of the words and a high chance of discarding few. Choosing half ensures
the maximum number of steps.</p>

<h4>Guess Who?</h4>

<p>The same algorithm can be applied to the children game Guess Who?. The optimal
strategy is to ask a question that will discard half of the options.</p>

<p>If you go to the opposite extreme, and ask a very specific question, it is
a high-risk, high-rewards scenario. It is very likely you have obtained little
information in most cases, but in a few you have guessed correctly.</p>

<h3>Properties</h3>

<p>Since we remove half of the options after each comparison, finding what we are
looking for is actually pretty fast. If we have a million options, we can
locate any one of them with up to 20 comparisons. And for a billion options,
up to only 30.</p>

<h2>Map/Reduce</h2>

<h3>Example</h3>

<h4>Elections</h4>

<p>When a small group of people want to have an election, where the vote is
secret, each will write down their desired output, gather all together, shuffle
and count the matching results.</p>

<p>This algorithm does not scale up well, since a big group of people will take a
long time to cast all votes and count them. Luckily, this is a problem that
was already solved by modern democratic states: they divide the people in
groups, each group will cast their votes, a group member will count the results
and summarize them in single a sheet of paper. All those papers are submitted
to a central person who adds up the votes to get the winner.</p>

<p>The act of counting each individual vote and write down a summary is called
"map". While making an overall summary of all summaries is "reduce".</p>

<h3>Properties</h3>

<p>The benefit of map/reduce is to divide a big problem into smallers that can be
parallelized.</p>
