<h1>Programming Concepts in the Real World</h1>

<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Attribution-ShareAlike 4.0 International" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"/></a></p>

<p>There are many aspects to programming that are needed to write code. In this
book we will focus only on some basic concepts that can be explained in
isolation, and may be interesting for non programmers.</p>

<h2>Algorithms</h2>

<h2>Binary Search</h2>

<h3>Example</h3>

<h4>Dictionary</h4>

<p>I want to look for a word in an English dictionary. An intuitive way to do it
is to open the dictionary in a random page look for any word, compare it with
the word I&#39;m looking for and see if it has to be before or after that one.
Then, I repeat the process and on every step the search range gets smaller
until I find out the word I was looking for.</p>

<p>Instead of looking for a random page, the fastest way for any word is to grab
the word in the exact middle. This way each step will discard exactly half of
the options available. Picking a random word has a small chance of discarding
most of the words and a high chance of discarding few. Choosing half ensures
the maximum number of steps.</p>

<h4>Guess Who?</h4>

<p>The same algorithm can be applied to the children game Guess Who?. The optimal
strategy is to ask a question that will discard half of the options.</p>

<p>If you go to the opposite extreme, and ask a very specific question, it is
a high-risk, high-rewards scenario. It is very likely you have obtained little
information in most cases, but in a few you have guessed correctly.</p>

<h3>Properties</h3>

<p>Since we remove half of the options after each comparison, finding what we are
looking for is actually pretty fast. If we have a million options, we can
locate any one of them with up to 20 comparisons. And for a billion options,
up to only 30.</p>

<h2>Map/Reduce</h2>

<h3>Example</h3>

<h4>Elections</h4>

<p>When a small group of people want to have an election, where the vote is
secret, each will write down their desired output, gather all together, shuffle
and count the matching results.</p>

<p>This algorithm does not scale up well, since a big group of people will take a
long time to cast all votes and count them. Luckily, this is a problem that
was already solved by modern democratic states: they divide the people in
groups, each group will cast their votes, a group member will count the results
and summarize them in single a sheet of paper. All those papers are submitted
to a central person who adds up the votes to get the winner.</p>

<p>The act of counting each individual vote and write down a summary is called
&quot;map&quot;. While making an overall summary of all summaries is &quot;reduce&quot;.</p>

<h3>Properties</h3>

<p>The benefit of map/reduce is to divide a big problem into smallers that can be
parallelized.</p>

<h2>Data Structures</h2>

<h2>Array</h2>

<h3>Example</h3>

<h4>Grocery List</h4>

<p>To make a grocery list you grab a sheet of paper and start writing from top to
bottom what you need to buy. This is the simplest way of making a list.</p>

<h3>Properties</h3>

<p>Adding items to an array at the end is easy. And adding more capacity
(including a second sheet of paper) is also possible.</p>

<p>It is not easy to add things in the middle of the list. It requires you to
copy every item one line below to have the free space where you want the
insertion.</p>

<h2>Linked List</h2>

<h3>Example</h3>

<h4>Field trip</h4>

<p>In a school field trip, stand all children in a line and ask them to remember
who is to their right. Now, you remember who is in each of the edges.</p>

<p>Now at any point, you can ask the first child to point to the second, and then
ask the second for the third, and so on. If you reach the last child then you
are sure that your list is complete.</p>

<h3>Properties</h3>

<p>In this schema, it is easy to add something at any point in the list. If the
list is sorted by some criteria, you can find where the insertion needs to
happen and just ask the previous node to point to the new value and the
new value to what the node was pointing at.</p>

<p>It is hard, though, to identify a node by its position. If you want to know
the position of a node, you have to start from the first and count until you
reach it.</p>

<h2>Double Linked List</h2>

<h3>Example</h3>

<h4>Grocery List</h4>

<p>This time, to make a grocery list we are going to write each item we want to
buy in a post-it. We can now attach any item we want to add to the list on any
position, which will help us to keep the list sorted in a convenient way.</p>

<p>We can also iterate the list from top to bottom or from bottom to top.</p>

<h4>Field trip</h4>

<p>In a school field trip, stand all children in a line and ask them to remember
who is to their right and to their left. Now, you remember who is in each of
the edges.</p>

<p>Now at any point, you can ask both of the edges to point to the next node, and
continue until both iterations reach the same node.</p>

<h3>Properties</h3>

<p>Like in the linked list case, we can easily insert nodes anywhere in the list,
but now we can iterate the nodes from either of the edges, but we are asking
each node to remember more.</p>

<h2>Hash Map</h2>

<h3>Example</h3>

<h4>Closet</h4>

<p>When organizing a closet, people usually group clothing by type. You&#39;ll see a
pile with t-shirts, a pile with pants, a socks drawer, etc. And now, whenever
you want to grab something, you go to the bucket that should contain it, see
all of the items in there and pick the right one.</p>

<p>Now, if we wanted to, we could add more granularity to the categories. Instead
of having a socks drawer we can have a green socks drawer, another for red
socks, another for white socks, and so on. As long as we know in which drawer
the sock we are looking for is, we can look it up faster, since we will have
less incorrect items in the drawer.</p>

<h3>Properties</h3>

<p>If we have enough buckets, we can add and look up any item really fast.</p>
